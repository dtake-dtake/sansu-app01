<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="app-title" content="(2けた)×(2けた)の筆算">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>(2けた)×(2けた)の筆算</title>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@500;800&display=swap" rel="stylesheet">
  <style>
/* ▼▼▼ テーマ：オレンジ・サンセット ▼▼▼ */
    :root {
      --c-bg-main: #FFF3E0;       /* 背景：やさしいクリームオレンジ */
      --c-card-bg: #ffffff;
      --c-grid-border: #FFCC80;   /* グリッド線：薄いオレンジ */
      --c-line-strong: #E65100;   /* 太線：濃いオレンジ */
      --c-primary: #FB8C00;       /* メインカラー：鮮やかなオレンジ */
      --c-primary-light: #FFE0B2; /* サブカラー：薄いオレンジ */
      --c-accent: #43A047;        /* アクセント：緑（オレンジと相性が良い） */
      --c-button-bg: #FB8C00;     /* ボタン背景 */
      
      --c-correct-bg: #E8F5E9;    /* 正解時の背景（薄い緑） */
      --c-wrong-bg: #FFEBEE;      /* 不正解時の背景（薄い赤） */
      --c-text-correct: #2E7D32;  /* 正解の文字色 */
      --c-text-wrong: #D32F2F;    /* 不正解の文字色 */

      --font-family: "M PLUS Rounded 1c", sans-serif;
      --cell-size: 58px;
    }

    body {
      font-family: var(--font-family);
      background-color: var(--c-bg-main);
      color: #37474F;
      padding: 20px;
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh;
      margin: 0;
      -webkit-tap-highlight-color: transparent;
      
      background-image: 
        linear-gradient(rgba(0,137,123,0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,137,123,0.1) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    h1 { font-size: 1.5rem; color: var(--c-primary); margin: 10px 0; text-align: center; background:rgba(255,255,255,0.8); padding:5px 15px; border-radius:10px;}
    
    .page-header {
      display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
      background: #fff; padding: 5px 15px; border-radius: 20px;
      border: 2px solid var(--c-primary);
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    #game-area {
      display: none; width: 100%; max-width: 600px;
      flex-direction: column; align-items: center;
    }

    .problem-card {
      background: var(--c-card-bg);
      border-radius: 10px;
      padding: 40px 30px; 
      box-shadow: 0 5px 15px rgba(0,0,0,0.15);
      display: flex; flex-direction: column; align-items: center;
      margin-bottom: 20px;
      position: relative;
      border: 2px solid var(--c-primary-light);
    }

    .problem-number-display {
      font-weight: bold; font-size: 1.2rem; color: #fff;
      margin-bottom: 15px;
      background: var(--c-primary);
      padding: 5px 20px; border-radius: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    /* ▼▼▼ 筆算グリッド ▼▼▼ */
    .hissan-grid {
      display: grid;
      grid-template-columns: repeat(5, var(--cell-size));
      gap: 0;
      border-top: 1px solid var(--c-grid-border);
      border-left: 1px solid var(--c-grid-border);
      font-size: 2.4rem; font-weight: bold; line-height: 1; color: #333;
      background-color: #fff;
      position: relative;
      margin: 10px 0;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      display: flex; align-items: center; justify-content: center;
      box-sizing: border-box;
      border-right: 1px solid var(--c-grid-border);
      border-bottom: 1px solid var(--c-grid-border);
      position: relative; 
    }

    .line-container {
      grid-column: 1 / -1; height: 0; position: relative; z-index: 5;
    }
    .line-bar {
      position: absolute; top: -2px; left: 0; right: 0; height: 3px; background-color: var(--c-line-strong);
    }

    .input-cell {
      width: 100%; height: 100%;
      font-family: inherit; font-size: inherit; font-weight: inherit;
      text-align: center;
      border: none; border-radius: 0;
      background-color: transparent;
      color: var(--c-primary); outline: none; padding: 0; margin: 0;
      -moz-appearance: textfield;
    }
    .input-cell:focus {
      background-color: rgba(255, 235, 59, 0.3);
      box-shadow: inset 0 0 0 2px var(--c-accent);
    }
    .input-cell::selection { background-color: rgba(255, 112, 67, 0.3); }

    /* ▼▼▼ くり上がりメモ ▼▼▼ */
    .carry-input {
      position: absolute;
      width: 20px; height: 20px;
      font-size: 0.9rem;
      text-align: center;
      border: 1px dashed #999;
      border-radius: 4px;
      background-color: #fff;
      z-index: 20;
      padding: 0; margin: 0;
      line-height: 18px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    .carry-input:focus {
      border: 2px solid var(--c-accent);
      background-color: #FFF3E0;
      transform: scale(1.3);
      z-index: 30;
    }

    /* 位置設定 */
    .carry-pos-tl { top: 2px; left: -12px; }
    .carry-pos-inner-tl { top: 2px; left: -12px; }

    /* 色分け */
    .carry-p1 { border-color: #F06292; color: #D81B60; background-color: #FCE4EC; }
    .carry-p2 { border-color: #64B5F6; color: #1565C0; background-color: #E3F2FD; }
    .carry-add { border-color: #FFB74D; color: #E65100; background-color: #FFF3E0; }

    .correct-bg { background-color: var(--c-correct-bg) !important; }
    .wrong-bg { background-color: var(--c-wrong-bg) !important; }
    
    .input-cell.correct { color: var(--c-text-correct); }
    .carry-input.correct { 
        color: var(--c-text-correct); 
        border-style: solid; 
        border-color: var(--c-text-correct);
        background-color: var(--c-correct-bg) !important; 
    }
    
    .input-cell.wrong { color: var(--c-text-wrong); }
    .carry-input.wrong { color: var(--c-text-wrong); background-color: #FFCDD2; }

    .symbol { font-family: sans-serif; font-size: 1.8rem; color: #555; }

    /* モード選択 */
    .mode-select-container {
        margin-bottom: 20px;
        background: #fff; padding: 15px; border-radius: 15px;
        border: 2px solid var(--c-primary-light);
        text-align: left;
    }
    .mode-option {
        display: flex; align-items: center; gap: 10px; margin: 10px 0; cursor: pointer;
        padding: 8px; border-radius: 8px; transition: background 0.2s;
    }
    .mode-option:hover { background-color: #F1F8E9; }
    .mode-option:has(input:checked) {
        background-color: #C8E6C9; 
        box-shadow: 0 0 0 2px var(--c-primary);
    }
    .mode-option input { transform: scale(1.5); accent-color: var(--c-primary); }
    .mode-label { font-weight: bold; font-size: 1.1rem; color: #37474F; }

    #start-area, #result-area {
      background: #fff; padding: 30px; border-radius: 15px;
      text-align: center; border: 4px solid var(--c-primary);
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
      max-width: 550px; width: 90%; margin-top: 20px;
    }

    .btn-area { margin-top: 20px; display: flex; justify-content: center; }
    button {
      font-family: var(--font-family);
      font-size: 1.3rem; padding: 12px 40px;
      border: none; border-radius: 50px;
      background-color: var(--c-button-bg); color: #fff;
      cursor: pointer; font-weight: bold;
      box-shadow: 0 5px 0 #004D40;
      transition: transform 0.1s;
    }
    button:active { transform: translateY(4px); box-shadow: none; }
    button:disabled { background-color: #ccc; box-shadow: none; cursor: not-allowed; }
    
    #check-btn { background-color: var(--c-accent); box-shadow: 0 5px 0 #BF360C; min-width: 200px; }
    #check-btn:active { transform: translateY(4px); box-shadow: none; }

    .star-rank { font-size: 3.5rem; color: #FFD700; text-shadow: 2px 2px 0 #FFA000; margin: 10px 0; }
    
    .status-container {
        display: flex; justify-content: space-around; flex-wrap: wrap;
        background-color: #F1F8E9; border-radius: 10px;
        padding: 10px; margin: 15px 0;
        border: 2px solid var(--c-primary-light);
    }
    .status-item {
        margin: 5px 10px; font-size: 0.95rem; color: #37474F;
        display: flex; flex-direction: column; align-items: center;
    }
    .status-label { font-size: 0.8rem; color: #78909C; margin-bottom: 2px; font-weight: bold; }
    .status-val { font-size: 1.2rem; font-weight: bold; color: var(--c-primary); }

    .history-container {
        margin-top: 20px; text-align: left;
        max-height: 200px; overflow-y: auto;
    }
    .history-title { font-size: 1rem; font-weight: bold; color: var(--c-primary); border-bottom: 2px solid var(--c-primary-light); margin-bottom: 5px; }
    .history-list { list-style: none; padding: 0; margin: 0; font-size: 0.85rem; }
    .history-item {
        display: grid; grid-template-columns: 1.5fr 1fr 0.8fr 0.8fr; 
        padding: 8px 5px; border-bottom: 1px solid #eee;
        align-items: center;
    }
    .history-item:nth-child(even) { background-color: #FAFAFA; }
    .hist-date { color: #555; font-size: 0.8rem; }
    .hist-rank { color: #FFD700; text-shadow: 1px 1px 0 #FFA000; font-size: 1rem; text-align: center; }
    .hist-score { font-weight: bold; color: var(--c-primary); text-align: right; }
    .hist-time { color: #78909C; text-align: right; }

    #feedback-circle {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 260px; height: 260px;
      border: 12px solid var(--c-accent); border-radius: 50%;
      opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 100;
    }
    #feedback-circle.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

    @media (max-width: 500px) {
      :root { --cell-size: 48px; }
      .problem-card { padding: 20px 10px; }
      .status-container { flex-direction: column; gap: 5px; }
      .history-item { grid-template-columns: 1fr 0.5fr 0.5fr 0.5fr; font-size: 0.8rem; }
    }
  </style>
</head>
<body>

  <h1 id="main-title"></h1>
  <div class="page-header">
    <span style="background:var(--c-primary); color:#fff; width:2em; height:2em; border-radius:50%; display:flex; justify-content:center; align-items:center; font-weight:bold;" id="page-num"></span>
    <span id="sub-title-text" style="font-weight:bold; color:var(--c-primary); margin-left:10px;"></span>
  </div>

  <div id="start-area">
    <h2 style="color:var(--c-primary); border:none; margin:0 0 20px 0;" id="start-title"></h2>
    
    <div class="mode-select-container">
        <div style="font-weight:bold; color:var(--c-primary); margin-bottom:10px;">コースをえらんでね</div>
        <label class="mode-option">
            <input type="radio" name="game-mode" value="standard" checked>
            <span class="mode-label">くり上がりメモが先</span>
        </label>
        <label class="mode-option">
            <input type="radio" name="game-mode" value="reverse">
            <span class="mode-label">くり上がりメモがあと</span>
        </label>
        <label class="mode-option">
            <input type="radio" name="game-mode" value="mental">
            <span class="mode-label">くり上がりメモなし</span>
        </label>
    </div>

    <div style="font-size:1.1rem; line-height:1.6; margin-bottom:20px; text-align:left; background:#E0F2F1; padding:15px; border-radius:10px; border:2px solid var(--c-primary-light);" id="start-desc">
    </div>

    <div class="status-container" style="margin-bottom: 20px;">
        <div class="status-item">
            <span class="status-label">今日のクリア</span>
            <span class="status-val" id="start-daily-clear-val">0</span>回
        </div>
        <div class="status-item">
            <span class="status-label">合計クリア</span>
            <span class="status-val" id="start-total-clear-val">0</span>回
        </div>
    </div>
    <button id="start-btn">スタート！ (Enter)</button>
    <div class="history-container">
        <div class="history-title">さいきんのきろく</div>
        <ul id="start-history-list" class="history-list"></ul>
    </div>
  </div>

  <div id="game-area">
    <div class="problem-number-display">
      もんだい <span id="current-q-num">1</span> / <span id="total-q-num">6</span>
    </div>

    <div class="problem-card">
      <div id="hissan-container"></div>
      <div id="feedback-circle"></div>
    </div>

    <div class="btn-area">
      <button id="check-btn">できた！ (Enter)</button>
    </div>
  </div>

  <div id="result-area" style="display:none;">
    <h2 style="color:var(--c-accent); margin:0;">全問クリア！</h2>
    <div id="result-stars" class="star-rank"></div>
    <div id="result-msg" style="font-size:1.4rem; font-weight:bold; margin:15px 0; color:#555;"></div>
    <div id="result-score" style="font-size:1.2rem; margin-bottom:10px;"></div>
    
    <div class="status-container">
        <div class="status-item">
            <span class="status-label">ハイスコア</span>
            <span class="status-val" id="high-score-val">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">今日のクリア</span>
            <span class="status-val" id="daily-clear-val">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">合計クリア</span>
            <span class="status-val" id="total-clear-val">0</span>
        </div>
    </div>

    <button id="retry-btn">もういちど</button>
    
    <div class="history-container">
        <div class="history-title">これまでのきろく</div>
        <ul id="result-history-list" class="history-list"></ul>
    </div>
  </div>

  <script>
    (function(){
        const config = {
            appId: "2keta_kakeru_2keta", 
            mainTitle: "１９　２けたをかけるかけ算の筆算",
            title: "(2けた)×(2けた)の筆算",
            page: 87,
            questionCount: 5,
            targetTime: 240, 
            starThresholds: { star5: 150, star4: 120, star3: 100 },
            startTitle: "学習のポイント",
            startDescription: "" 
        };

        let problems = [];
        let currentProblemIndex = 0;
        let startTime = 0;
        let currentScore = 100;
        let navigationOrder = []; 
        let incorrectInputs = []; 
        let currentMode = 'standard'; 

        const KEY_HS = `${config.appId}:hs`;
        const KEY_CLEAR = `${config.appId}:clear`;
        const KEY_DAILY_PREFIX = `${config.appId}:daily_`;
        const KEY_HISTORY = `${config.appId}:history_v2`; 
        const KEY_RANK = `${config.appId}:rank`; 
        const KEY_MODE = `${config.appId}:mode`; 

        function loadStats() {
            const ls = localStorage;
            const today = new Date().toDateString();
            
            return {
                highScore: parseInt(ls.getItem(KEY_HS) || 0),
                totalClear: parseInt(ls.getItem(KEY_CLEAR) || 0),
                dailyClear: parseInt(ls.getItem(KEY_DAILY_PREFIX + today) || 0),
                history: JSON.parse(ls.getItem(KEY_HISTORY) || "[]")
            };
        }

        function saveStats(score, starsStr, timeSec) {
            const ls = localStorage;
            const today = new Date().toDateString();
            const currentStats = loadStats();

            if (score > currentStats.highScore) {
                ls.setItem(KEY_HS, score);
                ls.setItem(KEY_RANK, starsStr);
            }
            ls.setItem(KEY_CLEAR, currentStats.totalClear + 1);
            ls.setItem(KEY_DAILY_PREFIX + today, currentStats.dailyClear + 1);

            const now = new Date();
            const dateStr = `${now.getMonth()+1}/${now.getDate()} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`; 
            
            const newEntry = {
                date: dateStr,
                score: score,
                stars: starsStr,
                time: timeSec,
                mode: currentMode
            };
            
            const newHistory = [newEntry, ...currentStats.history].slice(0, 10); 
            ls.setItem(KEY_HISTORY, JSON.stringify(newHistory));
            
            return loadStats(); 
        }

        function renderHistory(historyData, listId) {
            const listEl = document.getElementById(listId);
            listEl.innerHTML = "";
            historyData.forEach(h => {
                const li = document.createElement('li');
                li.className = 'history-item';
                let modeLabel = "";
                if(h.mode === "reverse") modeLabel = "(逆)";
                if(h.mode === "mental") modeLabel = "(暗)";

                li.innerHTML = `
                    <span class="hist-date">${h.date}</span>
                    <span class="hist-rank">${h.stars}</span>
                    <span class="hist-score">${h.score}点${modeLabel}</span>
                    <span class="hist-time">${h.time}秒</span>
                `;
                listEl.appendChild(li);
            });
        }

        function updateStatsDisplay() {
            const stats = loadStats();
            
            // Result Screen
            if(document.getElementById('high-score-val')){
                document.getElementById('high-score-val').textContent = stats.highScore;
                document.getElementById('daily-clear-val').textContent = stats.dailyClear;
                document.getElementById('total-clear-val').textContent = stats.totalClear;
            }

            // ★Start Screen (追加)
            if(document.getElementById('start-daily-clear-val')){
                document.getElementById('start-daily-clear-val').textContent = stats.dailyClear;
                document.getElementById('start-total-clear-val').textContent = stats.totalClear;
            }
            
            renderHistory(stats.history, 'start-history-list');
            renderHistory(stats.history, 'result-history-list');
        }

        function generateProblems(count) {
            const arr = [];
            for(let i=0; i<count; i++) {
                let a = Math.floor(Math.random() * 80) + 10;
                let b = Math.floor(Math.random() * 80) + 10;
                while (b % 10 === 0) {
                    b = Math.floor(Math.random() * 80) + 10;
                }

                if (Math.random() < 0.6) {
                     a = Math.floor(Math.random() * 70) + 25;
                     b = Math.floor(Math.random() * 70) + 25;
                     while (b % 10 === 0) {
                        b = Math.floor(Math.random() * 70) + 25;
                     }
                }
                
                // 0終わりの問題を作る確率を上げる
                if (Math.random() < 0.2) {
                    b = (Math.floor(Math.random() * 8) + 2) * 10;
                }
                
                const p1 = a * (b % 10);
                const p2 = a * Math.floor(b / 10);
                const total = a * b;

                const a_tens = Math.floor(a / 10);
                const a_ones = a % 10;
                const b_tens = Math.floor(b / 10);
                const b_ones = b % 10;

                const carry1 = Math.floor((a_ones * b_ones) / 10);
                const carry2 = Math.floor((a_ones * b_tens) / 10);

                const addCarries = [];
                let tempP1 = p1;
                let tempP2 = p2 * 10;
                let currentCarry = 0;
                
                // 1の位 (total)
                currentCarry = Math.floor(((tempP1 % 10) + (tempP2 % 10)) / 10);
                
                // 10の位 (total)
                tempP1 = Math.floor(tempP1 / 10); tempP2 = Math.floor(tempP2 / 10);
                let sum = (tempP1 % 10) + (tempP2 % 10) + currentCarry;
                
                if (total >= 1000) {
                    if (sum >= 10) addCarries.push({ col: 4, val: Math.floor(sum / 10) }); 
                }
                currentCarry = Math.floor(sum / 10);
                
                // 100の位 (total)
                tempP1 = Math.floor(tempP1 / 10); tempP2 = Math.floor(tempP2 / 10);
                sum = (tempP1 % 10) + (tempP2 % 10) + currentCarry;
                
                // ★修正：Col3(百の位)での繰り上がりも記録する
                if (sum >= 10) addCarries.push({ col: 3, val: Math.floor(sum / 10) });
                
                arr.push({ 
                    a, b, p1, p2, total, 
                    carry1, carry2, addCarries,
                    inputMap: {} 
                });
            }
            return arr;
        }

        function renderCurrentProblem() {
            const container = document.getElementById('hissan-container');
            container.innerHTML = "";
            document.getElementById('feedback-circle').className = "";
            const btn = document.getElementById('check-btn');
            btn.disabled = false;
            btn.textContent = "できた！ (Enter)";

            const prob = problems[currentProblemIndex];
            document.getElementById('current-q-num').textContent = currentProblemIndex + 1;

            const grid = document.createElement('div');
            grid.className = 'hissan-grid';
            
            const cellMap = {};
            const isZeroEnding = (prob.b % 10 === 0);

            const createInput = (correctVal, cellId, type="main") => {
                const input = document.createElement('input');
                input.type = "tel";
                if(type==="carry") input.className = "carry-input";
                else input.className = "input-cell";
                
                input.maxLength = 1;
                input.id = cellId;
                input.dataset.correct = correctVal;
                
                input.addEventListener('input', function() {
                    if (this.value.length >= 1) {
                        moveFocusLogical(this, 1);
                    }
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === "Enter") {
                        checkAnswer();
                    } else if (e.key === "Backspace") {
                        // ★全選択時または空の時は「前へ戻る」
                        const allSelected = input.selectionStart === 0 && input.selectionEnd === input.value.length;
                        if (input.value === "" || allSelected) {
                            e.preventDefault();
                            input.value = ""; // 全選択ならクリア
                            moveFocusLogical(input, -1);
                        }
                        // 文字がある場合はデフォルト動作（1文字消す）
                    } else if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                        e.preventDefault();
                        moveFocusSpatial(input, e.key);
                    }
                });
                
                input.addEventListener('focus', function() { this.select(); });
                
                prob.inputMap[cellId] = correctVal;
                return input;
            };

            // ★論理順序での移動（自動遷移・Backspace用）
            function moveFocusLogical(currentInput, direction) {
                // 現在の入力がincorrectInputsにある場合はそちらを優先、なければ通常ルート
                let list = navigationOrder;
                if (incorrectInputs.includes(currentInput)) {
                    list = incorrectInputs;
                }
                
                const idx = list.indexOf(currentInput);
                if (idx === -1) return;

                let nextIdx = idx + direction;
                while (nextIdx >= 0 && nextIdx < list.length) {
                    if (!list[nextIdx].disabled) {
                        list[nextIdx].focus();
                        return;
                    }
                    nextIdx += direction;
                }
            }

            // ★空間配置での移動（矢印キー用）
            function moveFocusSpatial(currentInput, key) {
                const container = document.getElementById('hissan-container');
                if(!container) return;
                
                const candidates = Array.from(container.querySelectorAll('input:not([disabled])'))
                                        .filter(el => el !== currentInput);
                
                if(candidates.length === 0) return;

                const rect = currentInput.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                
                let bestCandidate = null;
                let minDist = Infinity;

                candidates.forEach(cand => {
                    const cRect = cand.getBoundingClientRect();
                    const ccx = cRect.left + cRect.width / 2;
                    const ccy = cRect.top + cRect.height / 2;
                    
                    let isValid = false;
                    if (key === "ArrowUp") isValid = (ccy < cy - 10);
                    else if (key === "ArrowDown") isValid = (ccy > cy + 10);
                    else if (key === "ArrowLeft") isValid = (ccx < cx - 10);
                    else if (key === "ArrowRight") isValid = (ccx > cx + 10);
                    
                    if (isValid) {
                        const dx = Math.abs(ccx - cx);
                        const dy = Math.abs(ccy - cy);
                        let dist = 0;
                        if (key === "ArrowUp" || key === "ArrowDown") dist = dy + dx * 2;
                        else dist = dx + dy * 2;

                        if (dist < minDist) {
                            minDist = dist;
                            bestCandidate = cand;
                        }
                    }
                });

                if (bestCandidate) {
                    bestCandidate.focus();
                }
            }

            const addCell = (content, r, c) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                if (content instanceof HTMLElement) {
                    cell.appendChild(content);
                } else if (content) {
                    cell.textContent = content;
                }
                
                const shouldCreateCarry = (currentMode !== 'mental');

                if (isZeroEnding) {
                    if (r === 3 && c === 4) {
                        if (shouldCreateCarry && prob.carry2 > 0) {
                            const cm = createInput(prob.carry2, `c_zero_${currentProblemIndex}`, "carry");
                            cm.classList.add('carry-pos-tl', 'carry-p2'); 
                            cell.appendChild(cm);
                        }
                    }
                } else {
                    if (r === 3 && c === 5) {
                        if (shouldCreateCarry && prob.carry1 > 0) {
                            const cm1 = createInput(prob.carry1, `c1_q${currentProblemIndex}`, "carry");
                            cm1.classList.add('carry-pos-tl', 'carry-p1');
                            cell.appendChild(cm1);
                        }
                    }
                    if (r === 4 && c === 4) {
                        if (shouldCreateCarry && prob.carry2 > 0) {
                            const cm2 = createInput(prob.carry2, `c2_q${currentProblemIndex}`, "carry");
                            cm2.classList.add('carry-pos-tl', 'carry-p2');
                            cell.appendChild(cm2);
                        }
                    }
                    if (r === 5) {
                        prob.addCarries.forEach(ac => {
                            if (c === ac.col) {
                                if (shouldCreateCarry) {
                                    // ★判定: この列に「もともと数字がある」ならメモを作る。空なら作らない。
                                    const p2StrLen = String(prob.p2).length;
                                    // P2は10倍シフト。P2の一の位はCol 4。P2の百の位はCol 2。
                                    // グリッド列c(繰り上がり先)にP2の数字があるか
                                    // c=2(千)なら、P2が3桁(>=100)あれば存在する
                                    // c=3(百)なら、P2が2桁(>=10)あれば存在する
                                    // 式: c <= 4 && c > 4 - p2StrLen
                                    
                                    // ※ cは「繰り上がり先」の列。
                                    // generateProblemsで、Col 3で発生した繰り上がりは {col:3, val:1} と記録される。
                                    // 表示位置は Col 3 のセル内（次の桁 Col 2 へのメモとして左上に表示）
                                    // つまり、ターゲット列は「ac.col - 1」
                                    
                                    const targetCol = c - 1;
                                    const hasDigitP2 = (targetCol <= 4 && targetCol > 4 - p2StrLen);
                                    
                                    const p1StrLen = String(prob.p1).length;
                                    const hasDigitP1 = (targetCol <= 5 && targetCol > 5 - p1StrLen);
                                    
                                    if (hasDigitP2 || hasDigitP1) {
                                        const cmAdd = createInput(ac.val, `ca_${c}_q${currentProblemIndex}`, "carry");
                                        cmAdd.classList.add('carry-pos-inner-tl', 'carry-add');
                                        cell.appendChild(cmAdd);
                                    }
                                }
                            }
                        });
                    }
                }
                grid.appendChild(cell);
            };

            const addLine = () => {
                const lc = document.createElement('div'); lc.className = 'line-container';
                const bar = document.createElement('div'); bar.className = 'line-bar';
                lc.appendChild(bar); grid.appendChild(lc);
            };

            const aStr = String(prob.a);
            const bStr = String(prob.b);
            const p1Str = String(prob.p1);
            const p2Str = String(prob.p2);
            const totalStr = String(prob.total);

            // Row 1 & 2
            addCell("", 1, 1); addCell("", 1, 2); addCell("", 1, 3); addCell(aStr[0], 1, 4); addCell(aStr[1], 1, 5);
            addCell("", 2, 1); addCell("", 2, 2); 
            const sym = document.createElement('div'); sym.className='symbol'; sym.textContent="×";
            addCell(sym, 2, 3); addCell(bStr[0], 2, 4); addCell(bStr[1], 2, 5);
            addLine();

            // Row 3, 4, 5
            if (isZeroEnding) {
                // Row 3: Total (0 mode)
                for(let c=1; c<=5; c++) {
                    const len = totalStr.length;
                    if (c === 5) {
                        addCell(createInput("0", `r3c5_zero`), 3, c);
                    } else if (c > 5 - len) {
                        const char = totalStr[c - (5 - len + 1)];
                        addCell(createInput(char, `r3c${c}_zero`), 3, c);
                    } else {
                        addCell("", 3, c);
                    }
                }
            } else {
                // Normal mode
                // Row 3: P1
                for(let c=1; c<=5; c++) {
                    const len = p1Str.length;
                    if (c > 5 - len) {
                        const char = p1Str[c - (5 - len + 1)];
                        addCell(createInput(char, `r3c${c}`), 3, c);
                    } else {
                        addCell("", 3, c);
                    }
                }
                // Row 4: P2
                for(let c=1; c<=5; c++) {
                    const len = p2Str.length;
                    if (c <= 4 && c > 4 - len) {
                        const char = p2Str[c - (4 - len + 1)];
                        addCell(createInput(char, `r4c${c}`), 4, c);
                    } else {
                        addCell("", 4, c);
                    }
                }
                addLine();
                // Row 5: Total
                for(let c=1; c<=5; c++) {
                    const len = totalStr.length;
                    if (c > 5 - len) {
                        const char = totalStr[c - (5 - len + 1)];
                        addCell(createInput(char, `r5c${c}`), 5, c);
                    } else {
                        addCell("", 5, c);
                    }
                }
            }

            container.appendChild(grid);
            
            // --- ナビゲーション順序 ---
            navigationOrder = [];
            
            // DOMから要素を取得するヘルパー
            const getEl = (id) => document.getElementById(id);

            const pushIfExists = (id) => { const el = getEl(id); if (el) navigationOrder.push(el); };

            // Helper: Pair registration (Memo & Answer)
            const registerPair = (memoId, answerId) => {
                const mEl = getEl(memoId);
                const aEl = getEl(answerId);
                
                if (currentMode === 'reverse') {
                    if (aEl) navigationOrder.push(aEl);
                    if (mEl) navigationOrder.push(mEl);
                } else {
                    if (mEl) navigationOrder.push(mEl);
                    if (aEl) navigationOrder.push(aEl);
                }
            };

            if (isZeroEnding) {
                // 0省略モード
                pushIfExists(`r3c5_zero`); 
                registerPair(`c_zero_${currentProblemIndex}`, `r3c4_zero`);
                
                if (prob.total >= 1000) {
                     registerPair(`r3c2_zero`, `r3c3_zero`);
                } else {
                     pushIfExists(`r3c3_zero`);
                }
                
                pushIfExists(`r3c1_zero`); 
            } else {
                // 通常モード
                // 1. P1
                registerPair(`c1_q${currentProblemIndex}`, `r3c5`);
                pushIfExists(`r3c3`); 
                pushIfExists(`r3c4`); 

                // 2. P2
                registerPair(`c2_q${currentProblemIndex}`, `r4c4`);
                pushIfExists(`r4c2`);
                pushIfExists(`r4c3`);

                // 3. Total (ループで一般化)
                const handledColumns = new Set();

                for (let c = 5; c >= 1; c--) {
                    if (handledColumns.has(c)) continue;

                    const ansId = `r5c${c}`;
                    
                    // 「この桁(c)の計算」で発生した繰り上がり(addCarries[col:c])があるか
                    // ※繰り上がり先は c-1
                    const carryInfo = prob.addCarries.find(ac => ac.col === c);
                    const hasCarryOut = (carryInfo && carryInfo.val > 0);
                    
                    if (hasCarryOut) {
                        // 繰り上がり先(c-1)に、もともと数字があるか確認
                        const p2StrLen = String(prob.p2).length;
                        const hasDigitP2 = ((c-1) <= 4 && (c-1) > 4 - p2StrLen);
                        
                        const p1StrLen = String(prob.p1).length;
                        const hasDigitP1 = ((c-1) <= 5 && (c-1) > 5 - p1StrLen);
                        
                        const destinationHasValue = hasDigitP2 || hasDigitP1;

                        if (destinationHasValue) {
                            // もともと数字がある -> 計算が必要 -> メモあり
                            const carryToNextId = `ca_${c}_q${currentProblemIndex}`;
                            // ★修正：モードに従って登録する（registerPairを使用）
                            registerPair(carryToNextId, ansId); 
                        } else {
                            // 数字がない -> ただの桁あふれ(1) -> メモなし
                            // 順序: あふれた答え(c-1) -> 今の答え(c)  ※左から右へ (1 -> 8)
                            const nextAnsId = `r5c${c-1}`;
                            pushIfExists(nextAnsId);
                            pushIfExists(ansId); 
                            
                            handledColumns.add(c-1);
                        }
                    } else {
                        // 繰り上がりなし
                        
                        // ★1881のようなケースで、c=3(百)のとき、c=2(千)が空あふれの場合
                        if (c === 3 && prob.total >= 1000) {
                             const p2StrLen = String(prob.p2).length; 
                             const p2HasDigitAtCol2 = (p2StrLen >= 3);
                             
                             if (!p2HasDigitAtCol2) {
                                 const nextAnsId = `r5c2`;
                                 // 左(1) -> 右(8)
                                 pushIfExists(nextAnsId);
                                 pushIfExists(ansId);
                                 handledColumns.add(2);
                                 continue;
                             }
                        }
                        
                        pushIfExists(ansId);
                    }
                }
            }

            if(navigationOrder.length > 0) navigationOrder[0].focus();
        }

        function checkAnswer() {
            let allCorrect = true;
            incorrectInputs = []; 

            navigationOrder.forEach(input => {
                const correct = input.dataset.correct;
                const parentCell = input.closest('.cell');
                
                input.classList.remove('correct', 'wrong');
                if(parentCell && input.classList.contains('input-cell')) {
                    parentCell.classList.remove('correct-bg', 'wrong-bg');
                }
                
                if (input.value === correct) {
                    input.classList.add('correct');
                    if(parentCell && input.classList.contains('input-cell')) parentCell.classList.add('correct-bg');
                    input.disabled = true; 
                } else {
                    allCorrect = false;
                    input.classList.add('wrong');
                    if(parentCell && input.classList.contains('input-cell')) parentCell.classList.add('wrong-bg');
                    incorrectInputs.push(input);
                }
            });

            if (allCorrect) {
                document.getElementById('feedback-circle').classList.add('show');
                document.getElementById('check-btn').disabled = true;
                document.getElementById('check-btn').textContent = "せいかい！";
                
                if(window.confetti) confetti({ particleCount: 50, spread: 60, origin: { y: 0.6 } });

                setTimeout(() => {
                    currentProblemIndex++;
                    if (currentProblemIndex >= config.questionCount) {
                        showResult();
                    } else {
                        renderCurrentProblem();
                    }
                }, 1200);
            } else {
                currentScore = Math.max(0, currentScore - 5);
                if (incorrectInputs.length > 0) {
                    incorrectInputs[0].focus();
                }
            }
        }

        function showResult() {
            document.getElementById('game-area').style.display = 'none';
            document.getElementById('result-area').style.display = 'block';

            const timeSec = Math.floor((Date.now() - startTime) / 1000);
            let finalScore = currentScore;
            
            if (timeSec < config.targetTime) {
                finalScore += Math.floor((config.targetTime - timeSec) * 0.5); 
            }

            let stars = "★☆☆☆☆";
            let msg = "もう少し！";
            if (finalScore >= config.starThresholds.star5) { stars = "★★★★★"; msg = "すばらしい！計算マスター！"; }
            else if (finalScore >= config.starThresholds.star4) { stars = "★★★★☆"; msg = "よくがんばったね！"; }
            else if (finalScore >= config.starThresholds.star3) { stars = "★★★☆☆"; msg = "合格！その調子！"; }
            else if (finalScore >= 80) { stars = "★★☆☆☆"; msg = "あとすこし！"; }

            document.getElementById('result-stars').textContent = stars;
            document.getElementById('result-msg').textContent = msg;
            document.getElementById('result-score').innerHTML = `スコア: <strong>${finalScore}</strong> 点<br><span style="font-size:1rem; color:#888;">タイム: ${timeSec}秒</span>`;
            
            saveStats(finalScore, stars, timeSec);
            updateStatsDisplay();

            if (finalScore >= 100 && window.confetti) {
                confetti({ particleCount: 150, spread: 100, origin: { y: 0.6 } });
            }
        }

        function updateDescription(mode) {
            let desc = "";
            if (mode === 'standard') {
                desc = `① 計算したら、まずは<span style='color:#E65100; font-weight:bold;'>『くり上がりメモ』</span>を入力！<br>
                        ② そのあとに『答え』を書こう。<br>
                        ③ 最後のたし算も忘れずに！`;
            } else if (mode === 'reverse') {
                desc = `① 計算したら、先に<span style='color:#E65100; font-weight:bold;'>『答え』</span>を書こう！<br>
                        ② そのあとに『くり上がりメモ』を入力してね。<br>
                        ③ 最後のたし算も忘れずに！`;
            } else if (mode === 'mental') {
                desc = `① くり上がりは頭の中で！<br>
                        ② <span style='color:#E65100; font-weight:bold;'>『答え』だけ</span>をどんどん入力していこう。<br>
                        ③ 最後のたし算も忘れずに！`;
            }
            document.getElementById('start-desc').innerHTML = desc;
        }

        function initGame() {
            const radios = document.getElementsByName('game-mode');
            for(const r of radios) {
                if(r.checked) currentMode = r.value;
            }
            localStorage.setItem(KEY_MODE, currentMode);

            problems = generateProblems(config.questionCount);
            currentProblemIndex = 0;
            currentScore = 100;
            incorrectInputs = [];
            startTime = Date.now();

            document.getElementById('start-area').style.display = 'none';
            document.getElementById('result-area').style.display = 'none';
            document.getElementById('game-area').style.display = 'flex';
            
            renderCurrentProblem();
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('main-title').textContent = config.mainTitle;
            document.getElementById('page-num').textContent = config.page;
            document.getElementById('sub-title-text').textContent = config.title;
            // document.getElementById('start-title').textContent = config.startTitle; 
            document.getElementById('total-q-num').textContent = config.questionCount;
            
            const savedMode = localStorage.getItem(KEY_MODE);
            if (savedMode) {
                currentMode = savedMode;
                const radios = document.getElementsByName('game-mode');
                for(const r of radios) {
                    if(r.value === currentMode) r.checked = true;
                }
            }
            updateDescription(currentMode || 'standard');

            const radios = document.getElementsByName('game-mode');
            for(const r of radios) {
                r.addEventListener('change', (e) => {
                    currentMode = e.target.value;
                    updateDescription(currentMode);
                    localStorage.setItem(KEY_MODE, currentMode);
                });
            }
            
            updateStatsDisplay(); 

            document.getElementById('start-btn').addEventListener('click', initGame);
            document.getElementById('retry-btn').addEventListener('click', initGame);
            document.getElementById('check-btn').addEventListener('click', checkAnswer);

            document.addEventListener('keydown', (e) => {
                if (document.getElementById('start-area').style.display !== 'none') {
                    if (e.key === "Enter") {
                        initGame();
                    } else if (["ArrowDown", "ArrowRight", "ArrowUp", "ArrowLeft"].includes(e.key)) {
                        e.preventDefault(); 
                        const radios = Array.from(document.getElementsByName('game-mode'));
                        const currentIndex = radios.findIndex(r => r.checked);
                        let nextIndex = -1;

                        if (e.key === "ArrowDown" || e.key === "ArrowRight") {
                            nextIndex = (currentIndex + 1) % radios.length;
                        } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
                            nextIndex = (currentIndex - 1 + radios.length) % radios.length;
                        }

                        if (nextIndex !== -1) {
                            radios[nextIndex].checked = true;
                            currentMode = radios[nextIndex].value;
                            updateDescription(currentMode);
                            localStorage.setItem(KEY_MODE, currentMode);
                        }
                    }
                } else if (document.getElementById('result-area').style.display !== 'none') {
                    if (e.key === "Enter") {
                        initGame();
                    }
                }
            });
        });

    })();
  </script>
</body>
</html>