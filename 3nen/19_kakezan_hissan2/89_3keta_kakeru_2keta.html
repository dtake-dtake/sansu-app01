<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="app-title" content="(3けた)×(2けた)の筆算">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>(3けた)×(2けた)の筆算</title>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@500;800&display=swap" rel="stylesheet">
  <style>
    /* ▼▼▼ テーマ：方眼ノート・スクール ▼▼▼ */
    :root {
      --c-bg-main: #E0F2F1;
      --c-card-bg: #ffffff;
      --c-grid-border: #B0BEC5;    
      --c-line-strong: #455A64;    
      --c-primary: #00897B;
      --c-primary-light: #B2DFDB;
      --c-accent: #FF7043;
      --c-button-bg: #00897B;
      
      --c-correct-bg: #E8F5E9;
      --c-wrong-bg: #FFEBEE;
      --c-text-correct: #2E7D32;
      --c-text-wrong: #D32F2F;

      --font-family: "M PLUS Rounded 1c", sans-serif;
      --cell-size: 58px;
    }



    body {
      font-family: var(--font-family);
      background-color: var(--c-bg-main);
      color: #4E342E; /* 文字色はダークブラウン系 */
      padding: 20px;
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh;
      margin: 0;
      -webkit-tap-highlight-color: transparent;
      
      background-image: 
        radial-gradient(var(--c-primary-light) 2px, transparent 2px);
      background-size: 30px 30px;
    }

    h1 { font-size: 1.5rem; color: var(--c-primary); margin: 10px 0; text-align: center; background:rgba(255,255,255,0.9); padding:5px 15px; border-radius:10px; border-bottom: 3px solid var(--c-primary-light); }
    
    .page-header {
      display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
      background: #fff; padding: 5px 15px; border-radius: 20px;
      border: 2px solid var(--c-primary);
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    #game-area {
      display: none; width: 100%; max-width: 600px;
      flex-direction: column; align-items: center;
    }

    .problem-card {
      background: var(--c-card-bg);
      border-radius: 10px;
      padding: 30px 20px; 
      box-shadow: 0 5px 15px rgba(0,0,0,0.15);
      display: flex; flex-direction: column; align-items: center;
      margin-bottom: 20px;
      position: relative;
      border: 3px solid var(--c-primary-light);
    }

    .problem-number-display {
      font-weight: bold; font-size: 1.2rem; color: #fff;
      margin-bottom: 15px;
      background: var(--c-accent); /* アクセントカラーを使用 */
      padding: 5px 20px; border-radius: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    /* ▼▼▼ 筆算グリッド (5列×5行 完全固定) ▼▼▼ */
    .hissan-grid {
      display: grid;
      grid-template-columns: repeat(5, var(--cell-size)); 
      grid-template-rows: repeat(5, var(--cell-size));    
      gap: 0;
      border-top: 1px solid var(--c-grid-border);
      border-left: 1px solid var(--c-grid-border);
      font-size: 2.4rem; font-weight: bold; line-height: 1; color: #333;
      background-color: #fff;
      position: relative;
      margin: 15px 0 10px 0; 
    }

    .cell {
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      box-sizing: border-box;
      position: relative;
      border-right: 1px solid var(--c-grid-border);
      border-bottom: 1px solid var(--c-grid-border);
      z-index: 1; 
    }
    
    /* ▼▼▼ 線のスタイル（絶対配置） ▼▼▼ */
    .hissan-line {
      position: absolute;
      left: 0;
      width: 100%;
      height: 3px;
      background-color: var(--c-line-strong);
      pointer-events: none; 
      z-index: 5; 
    }

    .input-cell {
      width: 100%; height: 100%;
      font-family: inherit; font-size: inherit; font-weight: inherit;
      text-align: center;
      border: none; border-radius: 0;
      background-color: transparent;
      color: var(--c-accent); outline: none; padding: 0; margin: 0;
      -moz-appearance: textfield;
      transition: background-color 0.2s;
      z-index: 10; 
    }
    
    .input-cell:focus {
      background-color: rgba(255, 243, 224, 0.5);
      box-shadow: inset 0 0 0 3px var(--c-primary);
    }

    /* くり上がりメモ */
    .carry-input {
      position: absolute;
      width: 20px; height: 20px;
      font-size: 0.9rem;
      text-align: center;
      border: 1px dashed #999;
      border-radius: 4px;
      background-color: #fff;
      z-index: 20;
      padding: 0; margin: 0;
      line-height: 18px;
      box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      color: #777;
    }
    .carry-input:focus {
      border: 2px solid var(--c-primary);
      background-color: #FFF3E0;
      transform: scale(1.3);
      z-index: 30;
      color: var(--c-primary);
    }

    /* ★位置調整：左にはみ出す配置 (-12px) */
    .carry-pos-tl { top: 2px; left: -12px; } 

    .carry-p1 { border-color: #F06292; color: #D81B60; background-color: #FCE4EC; }
    .carry-p2 { border-color: #64B5F6; color: #1565C0; background-color: #E3F2FD; }
    .carry-add { border-color: #FFB74D; color: #E65100; background-color: #FFF3E0; }

    .correct-bg { background-color: var(--c-correct-bg) !important; }
    .wrong-bg { background-color: var(--c-wrong-bg) !important; }
    
    .input-cell.correct { color: var(--c-text-correct); font-weight: bold; }
    .carry-input.correct { 
        color: var(--c-text-correct); 
        border-style: solid;
        border-color: var(--c-text-correct);
        background-color: var(--c-correct-bg) !important; 
    }
    
    .input-cell.wrong { color: var(--c-text-wrong); font-weight: 800; }
    .carry-input.wrong { color: var(--c-text-wrong); background-color: #FFCDD2; }

    .symbol { font-family: sans-serif; font-size: 1.8rem; color: #555; }

    /* モード選択 */
    .mode-select-container {
        margin-bottom: 20px;
        background: #fff; padding: 15px; border-radius: 15px;
        border: 2px solid var(--c-primary-light);
        text-align: left;
    }
    .mode-option {
        display: flex; align-items: center; gap: 10px; margin: 10px 0; cursor: pointer;
        padding: 8px; border-radius: 8px; transition: background 0.2s;
    }
    .mode-option:hover { background-color: #FFF3E0; }
    
    /* 選択中のスタイル */
    .mode-option:has(input:checked) {
        background-color: #FFE0B2; 
        box-shadow: 0 0 0 2px var(--c-primary);
    }
    
    .mode-option input { transform: scale(1.5); accent-color: var(--c-primary); }
    .mode-label { font-weight: bold; font-size: 1.1rem; color: #37474F; }

    #start-area, #result-area {
      background: #fff; padding: 30px; border-radius: 15px;
      text-align: center; border: 4px solid var(--c-primary);
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
      max-width: 550px; width: 90%; margin-top: 20px;
    }

    .btn-area { margin-top: 20px; display: flex; justify-content: center; }
    button {
      font-family: var(--font-family);
      font-size: 1.3rem; padding: 12px 40px;
      border: none; border-radius: 50px;
      background-color: var(--c-button-bg); color: #fff;
      cursor: pointer; font-weight: bold;
      box-shadow: 0 5px 0 #E65100;
      transition: transform 0.1s;
    }
    button:active { transform: translateY(4px); box-shadow: none; }
    button:disabled { background-color: #ccc; box-shadow: none; cursor: not-allowed; }
    
    #check-btn { background-color: var(--c-accent); box-shadow: 0 5px 0 #1A237E; min-width: 220px; }
    #check-btn:active { transform: translateY(4px); box-shadow: none; }

    .star-rank { font-size: 3.5rem; color: #FFD700; text-shadow: 2px 2px 0 #FFA000; margin: 10px 0; }
    
    .status-container {
        display: flex; justify-content: space-around; flex-wrap: wrap;
        background-color: #FFF3E0; border-radius: 10px;
        padding: 10px; margin: 15px 0;
        border: 2px solid var(--c-primary-light);
    }
    .status-item {
        margin: 5px 10px; font-size: 0.95rem; color: #37474F;
        display: flex; flex-direction: column; align-items: center;
    }
    .status-label { font-size: 0.8rem; color: #78909C; margin-bottom: 2px; font-weight: bold; }
    .status-val { font-size: 1.2rem; font-weight: bold; color: var(--c-primary); }

    .history-container {
        margin-top: 20px; text-align: left;
        max-height: 200px; overflow-y: auto;
    }
    .history-title { font-size: 1rem; font-weight: bold; color: var(--c-primary); border-bottom: 2px solid var(--c-primary-light); margin-bottom: 5px; }
    .history-list { list-style: none; padding: 0; margin: 0; font-size: 0.85rem; }
    .history-item {
        display: grid; grid-template-columns: 1.5fr 1fr 0.8fr 0.8fr; 
        padding: 8px 5px; border-bottom: 1px solid #eee;
        align-items: center;
    }
    .history-item:nth-child(even) { background-color: #FAFAFA; }
    .hist-date { color: #555; font-size: 0.8rem; }
    .hist-rank { color: #FFD700; text-shadow: 1px 1px 0 #FFA000; font-size: 1rem; text-align: center; }
    .hist-score { font-weight: bold; color: var(--c-primary); text-align: right; }
    .hist-time { color: #78909C; text-align: right; }

    #feedback-circle {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 260px; height: 260px;
      border: 12px solid var(--c-accent); border-radius: 50%;
      opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 100;
    }
    #feedback-circle.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

    @media (max-width: 500px) {
      :root { --cell-size: 42px; }
      .problem-card { padding: 20px 5px; }
      h1 { font-size: 1.2rem; }
      .mode-label { font-size: 1rem; }
    }
  </style>
</head>
<body>

  <h1 id="main-title"></h1>
  <div class="page-header">
    <span style="background:var(--c-primary); color:#fff; width:2em; height:2em; border-radius:50%; display:flex; justify-content:center; align-items:center; font-weight:bold;" id="page-num"></span>
    <span id="sub-title-text" style="font-weight:bold; color:var(--c-primary); margin-left:10px;"></span>
  </div>

  <div id="start-area">
    <h2 style="color:var(--c-primary); border:none; margin:0 0 20px 0;" id="start-title"></h2>
    
    <div class="mode-select-container">
        <div style="font-weight:bold; color:var(--c-primary); margin-bottom:10px;">コースをえらんでね</div>
        <label class="mode-option">
            <input type="radio" name="game-mode" value="standard" checked>
            <span class="mode-label">くり上がりメモが先</span>
        </label>
        <label class="mode-option">
            <input type="radio" name="game-mode" value="reverse">
            <span class="mode-label">くり上がりメモがあと</span>
        </label>
        <label class="mode-option">
            <input type="radio" name="game-mode" value="mental">
            <span class="mode-label">くり上がりメモなし</span>
        </label>
    </div>

    <div style="font-size:1.1rem; line-height:1.6; margin-bottom:20px; text-align:left; background:#FFF3E0; padding:15px; border-radius:10px; border:2px solid var(--c-primary-light);" id="start-desc">
    </div>

    <div class="status-container" style="margin-bottom: 20px;">
        <div class="status-item">
            <span class="status-label">今日のクリア</span>
            <span class="status-val" id="start-daily-clear-val">0</span>回
        </div>
        <div class="status-item">
            <span class="status-label">合計クリア</span>
            <span class="status-val" id="start-total-clear-val">0</span>回
        </div>
    </div>
    
    <button id="start-btn">スタート！ (Enter)</button>
    <div class="history-container">
        <div class="history-title">さいきんのきろく</div>
        <ul id="start-history-list" class="history-list"></ul>
    </div>
  </div>

  <div id="game-area">
    <div class="problem-number-display">
      もんだい <span id="current-q-num">1</span> / <span id="total-q-num">6</span>
    </div>

    <div class="problem-card">
      <div id="hissan-container"></div>
      <div id="feedback-circle"></div>
    </div>

    <div class="btn-area">
      <button id="check-btn">できた！ (Enter)</button>
    </div>
  </div>

  <div id="result-area" style="display:none;">
    <h2 style="color:var(--c-accent); margin:0;">全問クリア！</h2>
    <div id="result-stars" class="star-rank"></div>
    <div id="result-msg" style="font-size:1.4rem; font-weight:bold; margin:15px 0; color:#555;"></div>
    <div id="result-score" style="font-size:1.2rem; margin-bottom:10px;"></div>
    
    <div class="status-container">
        <div class="status-item">
            <span class="status-label">ハイスコア</span>
            <span class="status-val" id="high-score-val">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">今日のクリア</span>
            <span class="status-val" id="daily-clear-val">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">合計クリア</span>
            <span class="status-val" id="total-clear-val">0</span>
        </div>
    </div>

    <button id="retry-btn">もういちど</button>
    
    <div class="history-container">
        <div class="history-title">これまでのきろく</div>
        <ul id="result-history-list" class="history-list"></ul>
    </div>
  </div>

  <script>
    (function(){
        const config = {
            appId: "3keta_kakeru_2keta", 
            mainTitle: "１９　２けたをかけるかけ算の筆算",
            title: "(3けた)×(2けた)の筆算",
            page: 89,
            questionCount: 5,
            targetTime: 300, 
            starThresholds: { star5: 160, star4: 130, star3: 100 },
            startTitle: "学習のポイント",
            startDescription: "" // 初期値（動的に設定）
        };

        let problems = [];
        let currentProblemIndex = 0;
        let startTime = 0;
        let currentScore = 100;
        let navigationOrder = []; 
        let incorrectInputs = []; 
        let currentMode = 'standard'; // standard, reverse, mental

        const KEY_HS = `${config.appId}:hs`;
        const KEY_CLEAR = `${config.appId}:clearCount`;
        const KEY_DAILY_PREFIX = `${config.appId}:daily_`;
        const KEY_HISTORY = `${config.appId}:history_v2`; 
        const KEY_RANK = `${config.appId}:rank`; 
        const KEY_MODE = `${config.appId}:mode`; // モード保存用キー

        function loadStats() {
            const ls = localStorage;
            const today = new Date().toDateString();
            return {
                highScore: parseInt(ls.getItem(KEY_HS) || 0),
                totalClear: parseInt(ls.getItem(KEY_CLEAR) || 0),
                dailyClear: parseInt(ls.getItem(KEY_DAILY_PREFIX + today) || 0),
                history: JSON.parse(ls.getItem(KEY_HISTORY) || "[]")
            };
        }

        function saveStats(score, starsStr, timeSec) {
            const ls = localStorage;
            const today = new Date().toDateString();
            const currentStats = loadStats();

            if (score > currentStats.highScore) {
                ls.setItem(KEY_HS, score);
                ls.setItem(KEY_RANK, starsStr);
            }
            
            // ★追加機能: クリア回数のカウントアップ
            ls.setItem(KEY_CLEAR, currentStats.totalClear + 1);
            ls.setItem(KEY_DAILY_PREFIX + today, currentStats.dailyClear + 1);

            const now = new Date();
            const dateStr = `${now.getMonth()+1}/${now.getDate()} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`; 
            
            const newEntry = { date: dateStr, score: score, stars: starsStr, time: timeSec, mode: currentMode };
            const newHistory = [newEntry, ...currentStats.history].slice(0, 10); 
            ls.setItem(KEY_HISTORY, JSON.stringify(newHistory));
            
            return loadStats(); 
        }

        function renderHistory(historyData, listId) {
            const listEl = document.getElementById(listId);
            listEl.innerHTML = "";
            historyData.forEach(h => {
                const li = document.createElement('li');
                li.className = 'history-item';
                let modeLabel = "";
                if(h.mode === "reverse") modeLabel = "(逆)";
                if(h.mode === "mental") modeLabel = "(暗)";
                
                li.innerHTML = `
                    <span class="hist-date">${h.date}</span>
                    <span class="hist-rank">${h.stars}</span>
                    <span class="hist-score">${h.score}点${modeLabel}</span>
                    <span class="hist-time">${h.time}秒</span>
                `;
                listEl.appendChild(li);
            });
        }

        function updateStatsDisplay() {
            const stats = loadStats();
            
            // リザルト画面の表示更新
            if(document.getElementById('high-score-val')){
                document.getElementById('high-score-val').textContent = stats.highScore;
                document.getElementById('daily-clear-val').textContent = stats.dailyClear;
                document.getElementById('total-clear-val').textContent = stats.totalClear;
            }

            // ★追加機能: スタート画面の表示更新
            if(document.getElementById('start-daily-clear-val')){
                document.getElementById('start-daily-clear-val').textContent = stats.dailyClear;
                document.getElementById('start-total-clear-val').textContent = stats.totalClear;
            }

            renderHistory(stats.history, 'start-history-list');
            renderHistory(stats.history, 'result-history-list');
        }

        function generateProblems(count) {
            const arr = [];
            for(let i=0; i<count; i++) {
                let a = Math.floor(Math.random() * 900) + 100;
                let b = Math.floor(Math.random() * 89) + 11;
                
                if (b % 10 === 0) b += 1;

                const a_digits = String(a).split('').map(Number);
                const b_digits = String(b).split('').map(Number);

                // --- P1 (a * b_ones) ---
                const p1_steps = [];
                let carry = 0;
                let val = a_digits[2] * b_digits[1];
                p1_steps.push({ digit: val % 10, carry: Math.floor(val / 10), targetCol: 5, carryTo: 4 });
                carry = Math.floor(val / 10);

                val = a_digits[1] * b_digits[1] + carry;
                p1_steps.push({ digit: val % 10, carry: Math.floor(val / 10), targetCol: 4, carryTo: 3 });
                carry = Math.floor(val / 10);

                val = a_digits[0] * b_digits[1] + carry;
                if (val >= 10) {
                     p1_steps.push({ digit: val % 10, highDigit: Math.floor(val / 10), targetCol: 3, highCol: 2 });
                } else {
                     p1_steps.push({ digit: val, targetCol: 3 });
                }

                // --- P2 (a * b_tens) ---
                const p2_steps = [];
                carry = 0;
                val = a_digits[2] * b_digits[0];
                p2_steps.push({ digit: val % 10, carry: Math.floor(val / 10), targetCol: 4, carryTo: 3 });
                carry = Math.floor(val / 10);

                val = a_digits[1] * b_digits[0] + carry;
                p2_steps.push({ digit: val % 10, carry: Math.floor(val / 10), targetCol: 3, carryTo: 2 });
                carry = Math.floor(val / 10);

                val = a_digits[0] * b_digits[0] + carry;
                if (val >= 10) {
                     p2_steps.push({ digit: val % 10, highDigit: Math.floor(val / 10), targetCol: 2, highCol: 1 });
                } else {
                     p2_steps.push({ digit: val, targetCol: 2 });
                }

                // --- Total Calculation (Addition) ---
                const p1 = a * b_digits[1];
                const p2 = a * b_digits[0]; 
                const total = a * b;
                
                const addCarries = [];
                let tempP1 = p1;
                let tempP2 = p2 * 10;
                let c = 0;
                
                let s = (tempP1%10) + (tempP2%10) + c; c = Math.floor(s/10);
                tempP1=Math.floor(tempP1/10); tempP2=Math.floor(tempP2/10);
                
                s = (tempP1%10) + (tempP2%10) + c; 
                if (s>=10) addCarries.push({ col: 3, val: Math.floor(s/10) });
                c = Math.floor(s/10);
                tempP1=Math.floor(tempP1/10); tempP2=Math.floor(tempP2/10);

                s = (tempP1%10) + (tempP2%10) + c;
                if (s>=10) addCarries.push({ col: 2, val: Math.floor(s/10) });
                c = Math.floor(s/10);
                tempP1=Math.floor(tempP1/10); tempP2=Math.floor(tempP2/10);
                
                s = (tempP1%10) + (tempP2%10) + c;
                if (s>=10) addCarries.push({ col: 1, val: Math.floor(s/10) });

                arr.push({ 
                    a, b, p1, p2, total, 
                    p1_steps, p2_steps, addCarries,
                    inputMap: {} 
                });
            }
            return arr;
        }

        function renderCurrentProblem() {
            const container = document.getElementById('hissan-container');
            container.innerHTML = "";
            document.getElementById('feedback-circle').className = "";
            const btn = document.getElementById('check-btn');
            btn.disabled = false;
            btn.textContent = "できた！ (Enter)";

            const prob = problems[currentProblemIndex];
            document.getElementById('current-q-num').textContent = currentProblemIndex + 1;

            const grid = document.createElement('div');
            grid.className = 'hissan-grid'; 
            
            const createInput = (correctVal, cellId, type="main") => {
                const input = document.createElement('input');
                input.type = "tel";
                input.className = (type==="carry") ? "carry-input" : "input-cell";
                input.maxLength = 1;
                input.id = cellId;
                input.dataset.correct = correctVal;
                
                input.addEventListener('input', function() {
                    if (this.value.length >= 1) {
                        moveFocus(this, 1);
                    }
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        checkAnswer();
                    } else if (e.key === "Backspace") {
                        const allSelected = input.selectionStart === 0 && input.selectionEnd === input.value.length;
                        if (input.value === "" || allSelected) {
                            e.preventDefault();
                            input.value = "";
                            moveFocus(input, -1);
                        }
                    } else if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                        e.preventDefault();
                        moveFocusSpatial(input, e.key);
                    }
                });
                
                input.addEventListener('focus', function() { this.select(); });
                
                prob.inputMap[cellId] = correctVal;
                return input;
            };

            function moveFocus(currentInput, direction) {
                const list = incorrectInputs.length > 0 ? incorrectInputs : navigationOrder;
                let idx = list.indexOf(currentInput);
                if (idx === -1) return;

                let nextIdx = idx + direction;
                while (nextIdx >= 0 && nextIdx < list.length) {
                    if (!list[nextIdx].disabled) {
                        list[nextIdx].focus();
                        return;
                    }
                    nextIdx += direction;
                }
            }

            function moveFocusSpatial(currentInput, key) {
                const container = document.getElementById('hissan-container');
                if(!container) return;
                
                const candidates = Array.from(container.querySelectorAll('input:not([disabled])'))
                                        .filter(el => el !== currentInput);
                
                if(candidates.length === 0) return;

                const rect = currentInput.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                
                let bestCandidate = null;
                let minDist = Infinity;

                candidates.forEach(cand => {
                    const cRect = cand.getBoundingClientRect();
                    const ccx = cRect.left + cRect.width / 2;
                    const ccy = cRect.top + cRect.height / 2;
                    
                    let isValid = false;
                    if (key === "ArrowUp") isValid = (ccy < cy - 10);
                    else if (key === "ArrowDown") isValid = (ccy > cy + 10);
                    else if (key === "ArrowLeft") isValid = (ccx < cx - 10);
                    else if (key === "ArrowRight") isValid = (ccx > cx + 10);
                    
                    if (isValid) {
                        const dx = Math.abs(ccx - cx);
                        const dy = Math.abs(ccy - cy);
                        let dist = 0;
                        if (key === "ArrowUp" || key === "ArrowDown") dist = dy + dx * 2;
                        else dist = dx + dy * 2;

                        if (dist < minDist) {
                            minDist = dist;
                            bestCandidate = cand;
                        }
                    }
                });

                if (bestCandidate) {
                    bestCandidate.focus();
                }
            }
            
            // 全セルを作成 (5x5)
            for(let r=1; r<=5; r++){
                for(let c=1; c<=5; c++){
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-r${r}-c${c}`;
                    grid.appendChild(cell);
                }
            }
            
            container.appendChild(grid);

            // 線を描画
            const lc1 = document.createElement('div'); 
            lc1.className = 'hissan-line';
            lc1.style.top = "calc(var(--cell-size) * 2 - 2px)"; 
            lc1.style.left = "var(--cell-size)"; 
            lc1.style.width = "calc(100% - var(--cell-size))";
            grid.appendChild(lc1);
            
            const lc2 = document.createElement('div'); 
            lc2.className = 'hissan-line';
            lc2.style.top = "calc(var(--cell-size) * 4 - 2px)";
            grid.appendChild(lc2);

            const aStr = String(prob.a);
            const bStr = String(prob.b);
            const totalStr = String(prob.total);

            // Row 1
            document.getElementById(`cell-r1-c3`).textContent = aStr[0];
            document.getElementById(`cell-r1-c4`).textContent = aStr[1];
            document.getElementById(`cell-r1-c5`).textContent = aStr[2];

            // Row 2
            const sym = document.createElement('div'); sym.className='symbol'; sym.textContent="×";
            document.getElementById(`cell-r2-c2`).appendChild(sym);
            document.getElementById(`cell-r2-c4`).textContent = bStr[0];
            document.getElementById(`cell-r2-c5`).textContent = bStr[1];

            navigationOrder = [];
            
            // --- helper to push in correct order ---
            const registerStep = (carryVal, carryClass, carryCellId, answerVal, answerCellId) => {
                let cm = null;
                // メモを作るかどうか
                if (carryVal > 0 && currentMode !== 'mental') {
                    // Carry Input作成
                    cm = createInput(carryVal, `c_${Math.random()}`, "carry"); 
                    cm.classList.add('carry-pos-tl', carryClass);
                    document.getElementById(carryCellId).appendChild(cm);
                }
                
                // Answer Input作成
                const res = createInput(answerVal, `a_${Math.random()}`); 
                document.getElementById(answerCellId).appendChild(res);

                // ナビゲーション順序登録
                if (currentMode === 'reverse') {
                    navigationOrder.push(res);
                    if (cm) navigationOrder.push(cm);
                } else {
                    if (cm) navigationOrder.push(cm);
                    navigationOrder.push(res);
                }
            };

            // --- P1入力配置 ---
            const s1 = prob.p1_steps[0];
            registerStep(s1.carry, 'carry-p1', `cell-r3-c${s1.targetCol}`, s1.digit, `cell-r3-c5`);

            const s2 = prob.p1_steps[1];
            registerStep(s2.carry, 'carry-p1', `cell-r3-c${s2.targetCol}`, s2.digit, `cell-r3-c4`);

            const s3 = prob.p1_steps[2];
            if (s3.highDigit !== undefined) {
                // 3桁目(digit)と4桁目(highDigit)を入力する
                // 標準/暗算モードなら、桁あふれの「1」→「3」の順（左から右）
                // 逆順モードなら、通常通り「3」→「1」
                if (currentMode === 'reverse') {
                    const res3 = createInput(s3.digit, `p1_c3`);
                    document.getElementById(`cell-r3-c3`).appendChild(res3);
                    navigationOrder.push(res3);
                    
                    const resHigh = createInput(s3.highDigit, `p1_c2`);
                    document.getElementById(`cell-r3-c2`).appendChild(resHigh);
                    navigationOrder.push(resHigh);
                } else {
                    // Standard / Mental: Left -> Right for final overflow (e.g. 1 then 3)
                    const resHigh = createInput(s3.highDigit, `p1_c2`);
                    document.getElementById(`cell-r3-c2`).appendChild(resHigh);
                    navigationOrder.push(resHigh);

                    const res3 = createInput(s3.digit, `p1_c3`);
                    document.getElementById(`cell-r3-c3`).appendChild(res3);
                    navigationOrder.push(res3);
                }
            } else {
                registerStep(0, '', '', s3.digit, `cell-r3-c3`);
            }

            // --- P2入力配置 ---
            const s1_p2 = prob.p2_steps[0];
            registerStep(s1_p2.carry, 'carry-p2', `cell-r4-c${s1_p2.targetCol}`, s1_p2.digit, `cell-r4-c4`);

            const s2_p2 = prob.p2_steps[1];
            registerStep(s2_p2.carry, 'carry-p2', `cell-r4-c${s2_p2.targetCol}`, s2_p2.digit, `cell-r4-c3`);

            const s3_p2 = prob.p2_steps[2];
            if (s3_p2.highDigit !== undefined) {
                if (currentMode === 'reverse') {
                    const res3_p2 = createInput(s3_p2.digit, `p2_c2`);
                    document.getElementById(`cell-r4-c2`).appendChild(res3_p2);
                    navigationOrder.push(res3_p2);
                    
                    const resHigh = createInput(s3_p2.highDigit, `p2_c1`);
                    document.getElementById(`cell-r4-c1`).appendChild(resHigh);
                    navigationOrder.push(resHigh);
                } else {
                    const resHigh = createInput(s3_p2.highDigit, `p2_c1`);
                    document.getElementById(`cell-r4-c1`).appendChild(resHigh);
                    navigationOrder.push(resHigh);

                    const res3_p2 = createInput(s3_p2.digit, `p2_c2`);
                    document.getElementById(`cell-r4-c2`).appendChild(res3_p2);
                    navigationOrder.push(res3_p2);
                }
            } else {
                registerStep(0, '', '', s3_p2.digit, `cell-r4-c2`);
            }

            // --- Total入力配置 ---
            for(let c=5; c>=1; c--) {
                const len = totalStr.length;
                const startCol = 5 - len + 1;
                
                // ★例外処理：5桁の答えで、かつ「4桁目(Col2)」を処理する時に、
                // 最上位(Col1)が単なる繰り上がり(P2なし)なら、[左->右]の順で入力させる
                if (c === 2 && startCol === 1) {
                    const p2StartCol = 4 - String(prob.p2).length + 1;
                    const isOverflowOnly = (1 < p2StartCol); 
                    
                    if (isOverflowOnly) {
                        // 左(Col1) -> 右(Col2) の順で生成
                        const val1 = totalStr[0];
                        const res1 = createInput(val1, `total_c1`);
                        document.getElementById(`cell-r5-c1`).appendChild(res1);
                        navigationOrder.push(res1);
                        
                        const val2 = totalStr[1];
                        const res2 = createInput(val2, `total_c2`);
                        document.getElementById(`cell-r5-c2`).appendChild(res2);
                        navigationOrder.push(res2);
                        
                        c--; 
                        continue;
                    }
                }

                if (c >= startCol) {
                    // 通常処理
                    let carryVal = 0;
                    const carryInfo = prob.addCarries.find(ac => ac.col === c - 1); 
                    let showMemo = false;

                    if (carryInfo) {
                        carryVal = carryInfo.val;
                        const p2StartCol = 4 - String(prob.p2).length + 1;
                        showMemo = true;
                        
                        // 足す相手がいない最上位桁への繰り上がりはメモ不要
                        if ((c-1) === 1 && (c-1) < p2StartCol) {
                             showMemo = false;
                        }
                    }
                    
                    if (currentMode === 'mental') showMemo = false;

                    if (showMemo && carryVal > 0) {
                        registerStep(carryVal, 'carry-add', `cell-r5-c${c}`, totalStr[c - startCol], `cell-r5-c${c}`);
                    } else {
                        const res = createInput(totalStr[c - startCol], `total_c${c}`);
                        document.getElementById(`cell-r5-c${c}`).appendChild(res);
                        navigationOrder.push(res);
                    }
                }
            }

            if(navigationOrder.length > 0) navigationOrder[0].focus();
        }

        function checkAnswer() {
            let allCorrect = true;
            incorrectInputs = []; 

            navigationOrder.forEach(input => {
                const correct = input.dataset.correct;
                const parentCell = input.closest('.cell');
                
                input.classList.remove('correct', 'wrong');
                if(parentCell && input.classList.contains('input-cell')) {
                    parentCell.classList.remove('correct-bg', 'wrong-bg');
                }
                
                if (input.value === correct) {
                    input.classList.add('correct');
                    if(parentCell && input.classList.contains('input-cell')) parentCell.classList.add('correct-bg');
                    input.disabled = true; 
                } else {
                    allCorrect = false;
                    input.classList.add('wrong');
                    if(parentCell && input.classList.contains('input-cell')) parentCell.classList.add('wrong-bg');
                    incorrectInputs.push(input);
                }
            });

            if (allCorrect) {
                document.getElementById('feedback-circle').classList.add('show');
                document.getElementById('check-btn').disabled = true;
                document.getElementById('check-btn').textContent = "せいかい！";
                
                if(window.confetti) confetti({ particleCount: 80, spread: 70, origin: { y: 0.6 } });

                setTimeout(() => {
                    currentProblemIndex++;
                    if (currentProblemIndex >= config.questionCount) {
                        showResult();
                    } else {
                        renderCurrentProblem();
                    }
                }, 1200);
            } else {
                currentScore = Math.max(0, currentScore - 5);
                if (incorrectInputs.length > 0) {
                    incorrectInputs[0].focus();
                    incorrectInputs[0].select();
                }
            }
        }

        function showResult() {
            document.getElementById('game-area').style.display = 'none';
            document.getElementById('result-area').style.display = 'block';

            const timeSec = Math.floor((Date.now() - startTime) / 1000);
            let finalScore = currentScore;
            
            if (timeSec < config.targetTime) {
                finalScore += Math.floor((config.targetTime - timeSec) * 0.3); 
            }

            let stars = "★☆☆☆☆";
            let msg = "ファイト！";
            if (finalScore >= config.starThresholds.star5) { stars = "★★★★★"; msg = "すばらしい！計算マスター！"; }
            else if (finalScore >= config.starThresholds.star4) { stars = "★★★★☆"; msg = "よくがんばったね！"; }
            else if (finalScore >= config.starThresholds.star3) { stars = "★★★☆☆"; msg = "合格！その調子！"; }
            else if (finalScore >= 80) { stars = "★★☆☆☆"; msg = "あとすこし！"; }

            document.getElementById('result-stars').textContent = stars;
            document.getElementById('result-msg').textContent = msg;
            document.getElementById('result-score').innerHTML = `スコア: <strong>${finalScore}</strong> 点<br><span style="font-size:1rem; color:#888;">タイム: ${timeSec}秒</span>`;
            
            saveStats(finalScore, stars, timeSec);
            updateStatsDisplay();

            if (finalScore >= 100 && window.confetti) {
                confetti({ particleCount: 150, spread: 100, origin: { y: 0.6 } });
            }
        }

        function updateDescription(mode) {
            let desc = "";
            if (mode === 'standard') {
                desc = `① 計算したら、まずは<span style='color:#E65100; font-weight:bold;'>『くり上がりメモ』</span>を入力！<br>
                        ② そのあとに『答え』を書こう。<br>
                        ③ 最後のたし算も忘れずに！`;
            } else if (mode === 'reverse') {
                desc = `① 計算したら、先に<span style='color:#E65100; font-weight:bold;'>『答え』</span>を書こう！<br>
                        ② そのあとに『くり上がりメモ』を入力してね。<br>
                        ③ 最後のたし算も忘れずに！`;
            } else if (mode === 'mental') {
                desc = `① くり上がりは頭の中で！<br>
                        ② <span style='color:#E65100; font-weight:bold;'>『答え』だけ</span>をどんどん入力していこう。<br>
                        ③ 最後のたし算も忘れずに！`;
            }
            document.getElementById('start-desc').innerHTML = desc;
        }

        function initGame() {
            const radios = document.getElementsByName('game-mode');
            for(const r of radios) {
                if(r.checked) currentMode = r.value;
            }
            
            localStorage.setItem(KEY_MODE, currentMode);

            problems = generateProblems(config.questionCount);
            currentProblemIndex = 0;
            currentScore = 100;
            incorrectInputs = [];
            startTime = Date.now();

            document.getElementById('start-area').style.display = 'none';
            document.getElementById('result-area').style.display = 'none';
            document.getElementById('game-area').style.display = 'flex';
            
            renderCurrentProblem();
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('main-title').textContent = config.mainTitle;
            document.getElementById('page-num').textContent = config.page;
            document.getElementById('sub-title-text').textContent = config.title;
            document.getElementById('start-title').textContent = config.startTitle;
            document.getElementById('start-desc').innerHTML = config.startDescription;
            document.getElementById('total-q-num').textContent = config.questionCount;
            
            const savedMode = localStorage.getItem(KEY_MODE);
            if (savedMode) {
                currentMode = savedMode;
                const radios = document.getElementsByName('game-mode');
                for(const r of radios) {
                    if(r.value === currentMode) r.checked = true;
                }
            }
            
            updateDescription(currentMode);

            const radios = document.getElementsByName('game-mode');
            for(const r of radios) {
                r.addEventListener('change', (e) => {
                    currentMode = e.target.value;
                    updateDescription(currentMode);
                    localStorage.setItem(KEY_MODE, currentMode);
                });
            }
            
            updateStatsDisplay(); 

            document.getElementById('start-btn').addEventListener('click', initGame);
            document.getElementById('retry-btn').addEventListener('click', initGame);
            document.getElementById('check-btn').addEventListener('click', checkAnswer);

            // ★改良：スタート画面でのキーボード操作
            document.addEventListener('keydown', (e) => {
                if (document.getElementById('start-area').style.display !== 'none') {
                    // Start画面
                    if (e.key === "Enter") {
                        initGame();
                    } else if (["ArrowDown", "ArrowRight", "ArrowUp", "ArrowLeft"].includes(e.key)) {
                        e.preventDefault(); 
                        const radios = Array.from(document.getElementsByName('game-mode'));
                        const currentIndex = radios.findIndex(r => r.checked);
                        let nextIndex = -1;

                        if (e.key === "ArrowDown" || e.key === "ArrowRight") {
                            nextIndex = (currentIndex + 1) % radios.length;
                        } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
                            nextIndex = (currentIndex - 1 + radios.length) % radios.length;
                        }

                        if (nextIndex !== -1) {
                            radios[nextIndex].checked = true;
                            currentMode = radios[nextIndex].value;
                            updateDescription(currentMode);
                            localStorage.setItem(KEY_MODE, currentMode);
                        }
                    }
                } else if (document.getElementById('result-area').style.display !== 'none') {
                    // リザルト画面
                    if (e.key === "Enter") {
                        initGame();
                    }
                }
            });
        });

    })();
  </script>
</body>
</html>